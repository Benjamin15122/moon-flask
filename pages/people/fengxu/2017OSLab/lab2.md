% Lab2系统调用
% 2017-3-24

# 1. 实验要求

本实验通过实现一个简单的应用程序，并在其中调用一个自定义实现的系统调用，介绍基于中断实现系统调用的全过程

# 1.1. 实现系统调用库函数`printf`

实验流程如下

1. Bootloader从实模式进入保护模式,加载内核至内存，并跳转执行
2. 内核初始化IDT（Interrupt Descriptor Table，中断描述符表），初始化GDT，初始化 TSS（Task State Segment，任务状态段）
3. 内核加载用户程序至内存，对内核堆栈进行设置，通过`iret`切换至用户空间，执行用户程序
4. 用户程序调用自定义实现的库函数`printf`打印字符串
5. `printf`基于中断陷入内核，由内核完成在视频映射的显存地址中写入内容，完成字符串的打印

# 1.2. 完善`printf`的格式化输出

格式化输出的测试用例在`lab2/app/main.c`中已给出

# 2. 相关资料

## 2.1. IA-32中断机制

### 2.1.1. IDT

中断到来之后，基于中断向量，IA-32硬件利用IDT与GDT这两张表寻找到对应的中断处理程序，并从当前程序跳转执行，下图显示的是基于中断向量寻找中断处理程序的流程

~~~~~~~~~~~~~~~~~~
                  IDT                                    EXECUTABLE SEGMENT
           +---------------+                             +---------------+
           |               |                       OFFSET|               |
           |---------------|  +------------------------->| ENTRY POINT   |
           |               |  |      LDT OR GDT          |               |
           |---------------|  |   +---------------+      |               |
           |               |  |   |               |      |               |
INTERRUPT  |---------------|  |   |---------------|      |               |
   ID----->| TRAP GATE OR  |--+   |               |      |               |
           |INTERRUPT GATE |--+   |---------------|      |               |
           |---------------|  |   |               |      |               |
           |               |  |   |---------------|      |               |
           |---------------|  +-->|   SEGMENT     |-+    |               |
           |               |      |  DESCRIPTOR   | |    |               |
           |---------------|      |---------------| |    |               |
           |               |      |               | |    |               |
           |---------------|      |---------------| |    |               |
           |               |      |               | |BASE|               |
           +---------------+      |---------------| +--->+---------------+
                                  |               |
                                  |               |
                                  |               |
                                  +---------------+
~~~~~~~~~~~~~~~~~~

其中IDT的基地址由`IDTR`寄存器（中断描述符表寄存器）保存，可利用`lidt`指令进行加载，其结构如下

~~~~~~~~~~~~~~~~~~
                                           INTERRUPT DESCRIPTOR TABLE
                                            +------+-----+-----+------+
                                      +---->|      |     |     |      |
                                      |     |- GATE FOR INTERRUPT #N -|
                                      |     |      |     |     |      |
                                      |     +------+-----+-----+------+
                                      |     *                         *
                                      |     *                         *
                                      |     *                         *
                                      |     +------+-----+-----+------+
                                      |     |      |     |     |      |
                                      |     |- GATE FOR INTERRUPT #2 -|
                                      |     |      |     |     |      |
                                      |     |------+-----+-----+------|
          IDT REGISTER                |     |      |     |     |      |
                                      |     |- GATE FOR INTERRUPT #1 -|
                  15            0     |     |      |     |     |      |
                 +---------------+    |     |------+-----+-----+------|
                 |   IDT LIMIT   |----+     |      |     |     |      |
+----------------+---------------|          |- GATE FOR INTERRUPT #0 -|
|            IDT BASE            |--------->|      |     |     |      |
+--------------------------------+          +------+-----+-----+------+
 31                             0
~~~~~~~~~~~~~~~~~~

IDT中每个表项称为门描述符（Gate Descriptor），门描述符可以分为3种

* Interrupt Gate，跳转执行该中断对应的处理程序时，`EFLAGS`中的`IF`位会被硬件置为`1`
* Trap Gate，跳转执行该中断对应的处理程序时，`EFLAGS`中的`IF`位不会置为`1`
* Task Gate，Intel设计用于任务切换，现代操作系统中一般不使用

门描述符的结构如下

~~~~~~~~~~~~~~~~~~
                            80386 TASK GATE
 31                23                15                7                0
+-----------------+-----------------+---+---+---------+-----------------+
|#############(NOT USED)############| P |DPL|0 0 1 0 1|###(NOT USED)####|4
|-----------------------------------+---+---+---------+-----------------|
|             SELECTOR              |#############(NOT USED)############|0
+-----------------+-----------------+-----------------+-----------------+

                              80386 INTERRUPT GATE
 31                23                15                7                0
+-----------------+-----------------+---+---+---------+-----+-----------+
|           OFFSET 31..16           | P |DPL|0 1 1 1 0|0 0 0|(NOT USED) |4
|-----------------------------------+---+---+---------+-----+-----------|
|             SELECTOR              |           OFFSET 15..0            |0
+-----------------+-----------------+-----------------+-----------------+

                              80386 TRAP GATE
 31                23                15                7                0
+-----------------+-----------------+---+---+---------+-----+-----------+
|          OFFSET 31..16            | P |DPL|0 1 1 1 1|0 0 0|(NOT USED) |4
|-----------------------------------+---+---+---------+-----+-----------|
|             SELECTOR              |           OFFSET 15..0            |0
+-----------------+-----------------+-----------------+-----------------+
~~~~~~~~~~~~~~~~~~

其中SELECTOR字段表示该中断对应的处理程序所在段的段描述符在GDT中的索引

若中断源为`int`等指令产生的软中断，IA-32硬件处理该中断时还会比较产生该中断的程序的CPL与该中断对应的门描述符的DPL字段，若CPL数值上大于DPL，则会产生General Protect Fault，即#GP异常

### 2.1.2. TSS

中断会改变程序正常执行的流程，为确保中断处理程序执行结束后能正确返回产生中断的程序，IA-32硬件会对产生中断的程序的`EFLAGS`，`CS`，`EIP`等寄存器在堆栈上进行保存

IA-32借助`TR`和TSS来确定保存`EFLAGS`，`CS`，`EIP`这些寄存器信息的新堆栈

`TR`（Task state segment Register）是16位的任务状态段寄存器，结构和`CS`这些段寄存器完全一样，它存放了GDT的一个索引，可以使用`ltr`指令进行加载，通过`TR`可以在GDT中找到一个TSS段描述符，索引过程如下

~~~~~~~~~~~~~~~~~~
                      +-------------------------+
                      |                         |
                      |                         |
                      |       TASK STATE        |
                      |        SEGMENT          |<---------+
                      |                         |          |
                      |                         |          |
                      +-------------------------+          |
       16-BIT VISIBLE             ^                        |
          REGISTER                |   HIDDEN REGISTER      |
   +--------------------+---------+----------+-------------+------+
TR |      SELECTOR      |      (BASE)        |       (LIMT)       |
   +---------+----------+--------------------+--------------------+
             |                    ^                     ^
             |                    +-----------------+   |
             |          GLOBAL DESCRIPTOR TABLE     |   |
             |        +-------------------------+   |   |
             |        |     TSS DESCRIPTOR      |   |   |
             |        +------+-----+-----+------+   |   |
             |        |      |     |     |      |---+   |
             |        |------+-----+-----+------|       |
             +------->|            |            |-------+
                      +------------+------------+
                      |                         |
                      +-------------------------+
~~~~~~~~~~~~~~~~~~

TSS是任务状态段，不同于代码段、数据段，TSS是一个系统段，用于存放任务的状态信息，主要用在硬件上下文切换

TSS提供了3个堆栈位置（`SS`和`ESP`），当发生堆栈切换的时候，CPU将根据目标代码特权级的不同，从TSS中取出相应的堆栈位置信息进行切换，例如我们的中断处理程序位于ring0，因此CPU会从TSS中取出`SS0`和`ESP0`进行切换

为了让硬件在进行堆栈切换的时候可以找到新堆栈，内核需要将新堆栈的位置写入TSS的相应位置，TSS中的其它内容主要在硬件上下文切换中使用，但是因为效率的问题大多数现代操作系统都不使用硬件上下文切换，因此TSS中的大部分内容都不会使用，其结构如下图所示

~~~~~~~~~~~~~~~~~~
 31              23              15              7             0
+---------------+---------------+---------------+-------------+-+
|          I/O MAP BASE         | 0 0 0 0 0 0 0   0 0 0 0 0 0 |T|64
|---------------+---------------+---------------+-------------+-|
|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|              LDT              |60
|---------------+---------------+---------------+---------------|
|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|              GS               |5C
|---------------+---------------+---------------+---------------|
|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|              FS               |58
|---------------+---------------+---------------+---------------|
|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|              DS               |54
|---------------+---------------+---------------+---------------|
|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|              SS               |50
|---------------+---------------+---------------+---------------|
|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|              CS               |4C
|---------------+---------------+---------------+---------------|
|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|              ES               |48
|---------------+---------------+---------------+---------------|
|                              EDI                              |44
|---------------+---------------+---------------+---------------|
|                              ESI                              |40
|---------------+---------------+---------------+---------------|
|                              EBP                              |3C
|---------------+---------------+---------------+---------------|
|                              ESP                              |38
|---------------+---------------+---------------+---------------|
|                              EBX                              |34
|---------------+---------------+---------------+---------------|
|                              EDX                              |30
|---------------+---------------+---------------+---------------|
|                              ECX                              |2C
|---------------+---------------+---------------+---------------|
|                              EAX                              |28
|---------------+---------------+---------------+---------------|
|                            EFLAGS                             |24
|---------------+---------------+---------------+---------------|
|                    INSTRUCTION POINTER (EIP)                  |20
|---------------+---------------+---------------+---------------|
|                          CR3  (PDPR)                          |1C
|---------------+---------------+---------------+---------------|
|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|              SS2              |18
|---------------+---------------+---------------+---------------|
|                             ESP2                              |14
|---------------+---------------+---------------+---------------|
|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|              SS1              |10
|---------------+---------------+---------------+---------------|
|                             ESP1                              |0C
|---------------+---------------+---------------+---------------|
|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|              SS0              |8
|---------------+---------------+---------------+---------------|
|                             ESP0                              |4
|---------------+---------------+---------------+---------------|
|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|   BACK LINK TO PREVIOUS TSS   |0
+---------------+---------------+---------------+---------------+
~~~~~~~~~~~~~~~~~~

中断到来/从中断返回的硬件行为如下

~~~~~~~~~~~~~~~~~~
old_CS = CS
old_EIP = EIP
old_SS = SS
old_ESP = ESP
target_CS = IDT[vec].selector
target_CPL = GDT[target_CS].DPL
if(target_CPL < GDT[old_CS].DPL)
    TSS_base = GDT[TR].base
    switch(target_CPL)
        case 0: 
            SS = TSS_base->SS0
            EPS = TSS_base->ESP0
        case 1: 
            SS = TSS_base->SS1
            EPS = TSS_base->ESP1
        case 2: 
            SS = TSS_base->SS2
    EPS = TSS_base->ESP2
    push old_SS
    push old_ESP
push EFLAGS
push old_CS
push old_EIP

################### iret ####################

old_CS = CS
pop EIP
pop CS
pop EFLAGS
if(GDT[old_CS].DPL < GDT[CS].DPL)
    pop ESP
    pop SS
~~~~~~~~~~~~~~~~~~

硬件堆栈切换只会在目标代码特权级比当前堆栈特权级高的时候发生，即`GDT[target_CS].DPL < GDT[SS].DPL`（这里的小于是数值上的），当`GDT[target_CS].DPL = GDT[SS].DPL`时，CPU将不会进行硬件堆栈切换

下图显示中断到来后内核堆栈的变化

~~~~~~~~~~~~~~~~~~
               WITHOUT PRIVILEGE TRANSITION

D  O      31          0                     31          0
I  F    |-------+-------|                 |-------+-------|
R       |#######|#######|    OLD          |#######|#######|    OLD
E  E    |-------+-------|   SS:ESP        |-------+-------|   SS:ESP
C  X    |#######|#######|     |           |#######|#######|     |
T  P    |-------+-------|<----+           |-------+-------|<----+
I  A    |  OLD EFLAGS   |                 |  OLD EFLAGS   |
O  N    |-------+-------|                 |-------+-------|
N  S    |#######|OLD CS |    NEW          |#######|OLD CS |
   I    |-------+-------|   SS:ESP        |-------+-------|
 | O    |    OLD EIP    |     |           |    OLD EIP    |    NEW
 | N    |---------------|<----+           |---------------|   SS:ESP
 |      |               |                 |  ERROR CODE   |     |
 !      *               *                 |---------------|<----+
        *               *                 |               |
        *               *
        WITHOUT ERROR CODE                 WITH ERROR CODE

                       WITH PRIVILEGE TRANSITION

D  O     31            0                     31          0
I  F    +-------+-------+<----+           +-------+-------+<----+
R       |#######|OLD SS |     |           |#######|OLD SS |     |
E  E    |-------+-------|   SS:ESP        |-------+-------|   SS:ESP
C  X    |    OLD ESP    |  FROM TSS       |    OLD ESP    |  FROM TSS
T  P    |---------------|                 |---------------|
I  A    |  OLD EFLAGS   |                 |  OLD EFLAGS   |
O  N    |-------+-------|                 |-------+-------|
N  S    |#######|OLD CS |    NEW          |#######|OLD CS |
   I    |-------+-------|   SS:ESP        |-------+-------|
 | O    |    OLD EIP    |     |           |    OLD EIP    |    NEW
 | N    |---------------|<----+           |---------------|   SS:ESP
 |      |               |                 |  ERROR CODE   |     |
 !      *               *                 |---------------|<----+
        *               *                 |               |
        *               *
        WITHOUT ERROR CODE                 WITH ERROR CODE
~~~~~~~~~~~~~~~~~~

## 2.2. 系统调用

系统调用的入口定义在`lib`下的`syscall.c`，在`syscall`函数里可以使用嵌入式汇编，先将各个参数分别赋值给`EAX`，`EBX`，`ECX`，`EDX`，`EDX`，`EDI`，`ESI`，然后约定将返回值放入`EAX`中（把返回值放入`EAX`的过程是我们需要在内核中实现的），接着使用`int`指令陷入内核

`int`指令接收一个8-Bits的立即数为参数，产生一个以该操作数为中断向量的软中断，其流程分为以下几步

1. 查找`IDTR`里面的IDT地址，根据这个地址找到IDT，然后根据IDT找到中断向量的门描述符
2. 检查CPL和门描述符的DPL，如果CPL数值上大于DPL，产生#GP异常，否则继续
3. 如果是一个ring3到ring0的陷入操作，则根据`TR`寄存器和GDT，找到TSS在内存中的位置，读取其中的`SS0`和`ESP0`并装载则向堆栈中压入`SS`和`ESP`，注意这个`SS`和`ESP`是之前用户态的数据
4. 压入`EFLAGS`，`CS`，`EIP`
5. 若门描述符为Interrupt Gate，则修改`EFLAGS`的`IF`位为0
6. 对于某些特定的中断向量，压入Error Code
7. 根据IDT表项设置`CS`和`EIP`，也就是跳转到中断处理程序执行

中断处理程序执行结束，需要从ring0返回ring3的用户态的程序时，使用`iret`指令

`iret`指令流程如下

1. `iret`指令将当前栈顶的数据依次Pop至`EIP`，`CS`，`EFLAGS`寄存器
2. 若Pop出的`CS`寄存器的CPL数值上大于当前的CPL，则继续将当前栈顶的数据依次Pop至`ESP`，`SS`寄存器
3. 恢复CPU的执行

# 3. 解决思路

保护模式下80386执行指令过程中产生的异常如下表总结，初始化IDT时，我们需要按照下表设置各个中断的处理程序

~~~~~~~~~~~~~~~~~~
Description               Interrupt   Return Address  Exception     Function That Can Generate
                          Number      Points to       Type          the Exception
                                      Faulting
                                      Instruction

Divide error               0          YES             FAULT         DIV, IDIV
Debug exceptions           1          
Breakpoint                 3          NO              TRAP          One-byte INT 3
Overflow                   4          NO              TRAP          INTO
Bounds check               5          YES             FAULT         BOUND
Invalid opcode             6          YES             FAULT         Any illegal instruction
Coprocessor not available  7          YES             FAULT         ESC, WAIT
Double fault               8          YES             ABORT         Any instruction that can
                                                                    generate an exception
Coprocessor Segment        9          NO              ABORT         Any operand of an ESC
Overrun                                                             instruction that wraps around
                                                                    the end of a segment
Invalid TSS               10          YES             FAULT
Segment not present       11          YES             FAULT         Any segment-register modifier
Stack exception           12          YES             FAULT         Any memory reference thru SS
General Protection        13          YES             FAULT/ABORT
Page fault                14          YES             FAULT         Any memory reference or code
                                                                    fetch
Coprocessor error         16          YES             FAULT
Two-byte SW Interrupt     0-255       NO              TRAP          INT n
~~~~~~~~~~~~~~~~~~

保护模式下80386执行指令过程中产生异常时所产生的Error Code的总结

~~~~~~~~~~~~~~~~~~
Description                       Interrupt     Error Code
                                  Number

Divide error                       0            No
Debug exceptions                   1            No
Breakpoint                         3            No
Overflow                           4            No
Bounds check                       5            No
Invalid opcode                     6            No
Coprocessor not available          7            No
System error                       8            Yes (always 0)
Coprocessor Segment Overrun        9            No
Invalid TSS                       10            Yes
Segment not present               11            Yes
Stack exception                   12            Yes
General protection fault          13            Yes
Page fault                        14            Yes
Coprocessor error                 16            No
Two-byte SW interrupt             0-255         No
~~~~~~~~~~~~~~~~~~

# 4. 代码框架

~~~~~~~~~~~~~~~~~~
+Lab2
|---+bootloader             #引导程序
|   |---...
|---+utils
|   |---genBoot.pl          #生成引导程序
|   |---genKernel.pl        #生成内核程序
|---+kernel
|   |---+include            #头文件
|   |---+kernel             #内核代码
|   |   |---doIrq.S         #中断处理
|   |   |---i8259.c         #重设主从8259A
|   |   |---idt.c           #初始化中断描述表
|   |   |---irqHandle.c     #中断处理函数
|   |   |---kvm.c           #初始化 GDT 和加载用户程序
|   |   |---serial.c        #初始化串口输出
|   |---+lib
|   |---main.c              #主函数
|   |---Makefile
|---+app                    #用户代码
|   |---main.c              #主函数
|   |---Makefile
|---+lib                    #库函数
|   |---lib.h
|   |---types.h
|   |---syscall.c           #系统调用入口
|---Makefile
~~~~~~~~~~~~~~~~~~

# 5. 相关资源

* [代码框架](lab02.zip)

# 6. 作业提交

截止时间：2017-4-7 00:00:00
