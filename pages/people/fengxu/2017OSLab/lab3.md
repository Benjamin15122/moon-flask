% Lab3进程切换
% 2017-4-7

# 1. 实验要求

本实验通过实现一个简单的任务调度，介绍基于时间中断进行进程切换完成任务调度的全过程

## 1.1. 实现进程切换机制

在内核中实现进程切换机制，并基于时间中断进行任务调度，具体流程如下

1. Bootloader从实模式进入保护模式,加载内核至内存，并跳转执行
2. 内核初始化IDT，初始化GDT，初始化TSS，初始化串口，初始化8259A，...
3. 启动时钟源
4. 加载用户程序至内存
5. 初始化内核IDLE线程的进程控制块（Process Control Block），初始化用户程序的进程控制块
6. 切换至用户程序的内核堆栈，弹出用户程序的现场信息，返回用户态执行用户程序

## 1.2. 实现`FORK`、`SLEEP`、`EXIT`系统调用

实现`FORK`、`SLEEP`、`EXIT`系统调用，并使用以下用户程序测试

~~~~~~~~~~~~~~~~~~
#include "lib.h"

int data = 0;

int uEntry(void) {
	int ret = fork();
	int i = 8;

	if (ret == 0) {
		data = 2;
		while( i != 0) {
			i --;
			printf("Child Process: Pong %d, %d;\n", data, i);
			sleep(128);
		}
		exit();
	}
	else if (ret != -1) {
		data = 1;
		while( i != 0) {
			i --;
			printf("Father Process: Ping %d, %d;\n", data, i);
			sleep(128);
		}
		exit();
	}
	
	return 0;
}
~~~~~~~~~~~~~~~~~~

# 2. 相关资料

## 2.1. 启动时钟源

使用以下代码对8253可编程计时器进行设置，使得8253以频率`HZ`产生时间中断信号发送给8259A可编程中断控制器；若依照代码框架`lab2/kernel/kernel/i8259.c`中给出的配置示例对8259A进行设置，则该中断的中断向量为`0x20`，对此中断设置时间中断处理程序

~~~~~~~~~~~~~~~~~~
#define TIMER_PORT 0x40
#define FREQ_8253 1193182
#define HZ 100

void initTimer() {
	int counter = FREQ_8253 / HZ;
	outByte(TIMER_PORT + 3, 0x34);
	outByte(TIMER_PORT + 0, counter % 256);
	outByte(TIMER_PORT + 0, counter / 256);
}
~~~~~~~~~~~~~~~~~~

## 2.2. 进程与线程

进程为操作系统资源分配的单位，每个进程都有独立的地址空间（代码段、数据段），独立的堆栈，独立的进程控制块；线程作为任务调度的基本单位，与进程的唯一区别在于其地址空间并非独立，而是与其他线程共享；以下为一个广义的进程（包括进程与线程）生命周期中的状态转换图

* 进程由其父进程利用`FORK`系统调用创建，则该进程进入`RUNNABLE`状态
* 时间中断到来，`RUNNABLE`状态的进程被切换到，则该进程进入`RUNNING`状态
* 时间中断到来，`RUNNING`状态的进程处理时间片耗尽，则该进程进入`RUNNABLE`状态
* `RUNNING`状态的进程利用`SLEEP`系统调用主动阻塞；或利用系统调用等待硬件I/O，则该进程进入`BLOCKED`状态
* 时间中断到来，`BLOCKED`状态的进程的`SLEEP`时间片耗尽；或外部硬件中断表明I/O完成，则该进程进入`RUNNABLE`状态
* `RUNNING`状态的进程利用`EXIT`系统调用主动销毁，则该进程进入`DEAD`状态

~~~~~~~~~~~~~~~~~~
                                 +------------+
            SLEEP TIME EXPIRED   |            |        SLEEP SYSCALL
               I/O FINISHED  +---+  BLOCKED   +<--+  I/O REQUEST SYSCALL
                             |   |            |   |
                             |   +------------+   |
                             V                    |
+------------+ FORK    +-----+------+      +------+-----+ EXIT    +------------+
|            | SYSCALL |            +<-----+            | SYSCALL |            |
|     NEW    +-------->+  RUNNABLE  |      |  RUNNING   +-------->+    DEAD    |
|            |         |            +----->+            |         |            |
+------------+         +------------+      +------------+         +------------+
~~~~~~~~~~~~~~~~~~

### 2.2.1. `FORK`系统调用

`FORK`系统调用用于创建子进程，内核需要为子进程分配一块独立的内存，将父进程的地址空间、用户态堆栈完全拷贝至子进程的内存中，并为子进程分配独立的进程控制块，完成对子进程的进程控制块的设置

若子进程创建成功，则对于父进程，该系统调用的返回值为子进程的`pid`，对于子进程，其返回值为`0`；若子进程创建失败，该系统调用的返回值为`-1`

~~~~~~~~~~~~~~~~~~
int fork();
~~~~~~~~~~~~~~~~~~

### 2.2.2. `SLEEP`系统调用

`SLEEP`系统调用用于进程主动阻塞自身，内核需要将该进程由`RUNNING`状态转换为`BLOCKED`状态，设置该进程的`SLEEP`时间片，并切换运行其他`RUNNABLE`状态的进程

~~~~~~~~~~~~~~~~~~
int sleep(uint32_t time);
~~~~~~~~~~~~~~~~~~

### 2.2.3. `EXIT`系统调用

`EXIT`系统调用用于进程主动销毁自身，内核需要将该进程由`RUNNING`状态转换为`DEAD`状态，回收分配给该进程的内存、进程控制块等资源，并切换运行其他`RUNNABLE`状态的进程

~~~~~~~~~~~~~~~~~~
int exit();
~~~~~~~~~~~~~~~~~~

### 2.2.4. 内核IDLE线程

若没有处于`RUNNABLE`状态的进程可供切换，则需要切换至以下内核IDLE线程，该线程调用`waitForInterrupt()`执行`hlt`指令，`hlt`会使得CPU进入暂停状态，直到外部硬件中断产生

~~~~~~~~~~~~~~~~~~
static inline void waitForInterrupt() {
	asm volatile("hlt");
}
...
while(1)
	waitForInterrupt();
...
~~~~~~~~~~~~~~~~~~

# 3. 解决思路

## 3.1. 进程控制块

使用`ProcessTable`这一数据结构作为进程控制块记录每个进程的信息，其中`stack[MAX_STACK_SIZE]`为每个进程独立的内核堆栈，`tf`记录每个进程从用户态陷入内核态时压入内核堆栈的信息（即所有寄存器信息、中断号、Error Code），`state`记录每个进程的状态（即`RUNNING`、`RUNNABLE`、`BLOCKED`、`DEAD`等），`timeCount`记录每个进程的处理（`RUNNING`）时间片，`sleepTime`记录每个进程阻塞（`BLOCKED`）的时间片，`pid`记录每个进程的进程号

~~~~~~~~~~~~~~~~~~
struct TrapFrame {
	uint32_t gs, fs, es, ds;
	uint32_t edi, esi, ebp, xxx, ebx, edx, ecx, eax;
	uint32_t irq;                   // 中断号
	uint32_t error;                 // Error Code
	uint32_t eip, cs, eflags, esp, ss;
};

struct ProcessTable {
	uint32_t stack[MAX_STACK_SIZE]; // 内核堆栈
	struct TrapFrame tf;
	int state;
	int timeCount;
	int sleepTime;
	uint32_t pid;
	...
};

struct ProcessTable pcb[MAX_PCB_NUM];
~~~~~~~~~~~~~~~~~~

## 3.2. 进程切换与堆栈切换

下图为产生时间中断后，时间中断处理程序为两个用户态进程P1、P2进行进程切换的过程中，堆栈切换的简单图示

1. 进程P1在用户态执行，8253可编程计时器产生时间中断
2. 依据TSS中记录的进程P1的`SS0:EPS0`，从P1的用户态堆栈切换至P1的内核堆栈，并将P1的现场信息压入内核堆栈中，跳转执行时间中断处理程序
3. 进程P1的处理时间片耗尽，切换至就绪状态的进程P2，并从当前P1的内核堆栈切换至P2的内核堆栈
4. 从进程P2的内核堆栈中弹出P2的现场信息，切换至P2的用户态堆栈，从时间中断处理程序返回执行P2

~~~~~~~~~~~~~~~~~~
D  O       31            0                    31            0
I  F      +-------+-------+                  +-------+-------+
R         |#######|#######|    OLD           |#######|#######|
E  E      +-------+-------+   SS:ESP OF P1   +-------+-------+
C  X      |#######|#######|     |            |#######|#######|
T  P      +-------+-------+<----+            +-------+-------+
I  A      |               |                  |#######|#######|    NEW
O  N      |               |                  +-------+-------+   SS:ESP OF P2
N  S      |               |                  |#######|#######|     |
   I      |               |                  +-------+-------+<----+
 | O      |               |                  |               |
 | N      |               |                  |               |
 |        |               |                  |               |
 !        *               *                  *               *
          *               *                  *               *
      +-- *               *                  *               * <-+
      |   USER STACK OF P1                   USER STACK OF P2    |
      |                                                          |
      | ENTER                                                    | LEAVE
      | KERNEL                                                   | KERNEL
      | SPACE                                                    | SPACE
      |                                                          |
D  O  |    31            0                   31            0     |
I  F  +-> +-------+-------+ ---------------> +-------+-------+ --+
R         |#######|#######|      SWITCH      |#######|#######|
E  E      +-------+-------+   KERNEL STACK   +-------+-------+
C  X      |#######|#######|                  |#######|#######|
T  P      +---------------+                  +---------------+
I  A      |      PID      |                  |      PID      |
O  N      +---------------+                  +---------------+
N  S      |   SLEEPTIME   |                  |   SLEEPTIME   |
   I      +---------------+                  +---------------+
 | O      |   TIMECOUNT   |                  |   TIMECOUNT   |
 | N      +---------------+                  +---------------+
 |        |     STATE     |                  |     STATE     |
 !        +-------+-------+<----+            +-------+-------+<----+
          |#######|  SS   |     |            |#######|  SS   |     |
          +---------------+  SS0:ESP0 OF P1  +---------------+  SS0:ESP0 OF P2
          |      ESP      |  FROM TSS        |      ESP      |  FROM TSS
          +---------------+                  +---------------+
          |     EFLAGS    |                  |     EFLAGS    |
          +-------+-------+                  +-------+-------+
          |#######|  CS   |                  |#######|  CS   |
          +-------+-------+                  +-------+-------+
          |      EIP      |                  |      EIP      |
          +---------------+                  +---------------+
          |     ERROR     |                  |     ERROR     |
          +---------------+                  +---------------+
          |      IRQ      |                  |      IRQ      |
          +---------------+                  +---------------+
          |      EAX      |                  |      EAX      |
          +---------------+                  +---------------+
          |      ECX      |                  |      ECX      |
          +---------------+                  +---------------+
          |      EDX      |                  |      EDX      |
          +---------------+                  +---------------+
          |      EBX      |                  |      EBX      |
          +---------------+                  +---------------+
          |      XXX      |                  |      XXX      |
          +---------------+                  +---------------+
          |      EBP      |                  |      EBP      |
          +---------------+                  +---------------+
          |      ESI      |                  |      ESI      |
          +---------------+                  +---------------+
          |      EDI      |                  |      EDI      |
          +-------+-------+                  +-------+-------+
          |#######|  DS   |                  |#######|  DS   |
          +-------+-------+                  +-------+-------+
          |#######|  ES   |                  |#######|  ES   |
          +-------+-------+                  +-------+-------+
          |#######|  FS   |    NEW           |#######|  FS   |    OLD
          +-------+-------+   SS:ESP OF P1   +-------+-------+   SS:ESP OF P2
          |#######|  GS   |     |            |#######|  GS   |     |
          +-------+-------+<----+            +-------+-------+<----+
          |               |                  |               |
          *               *                  *               *
          *               *                  *               *
          *               *                  *               *
          KERNEL STACK OF P1                 KERNEL STACK OF P2
~~~~~~~~~~~~~~~~~~

## 3.3. 中断嵌套与临界区

由于系统调用的处理时间往往很长，为保证进程调度的公平性，需要在系统调用中开启外部硬件中断，以便当前进程的处理时间片耗尽时，进行进程切换；由于可以在系统调用中进行进程切换，因此可能会出现多个进程并发地处理系统调用，对共享资源（例如内核的数据结构，视频显存等等）进行竞争，例如以下场景

1. 进程P1在内核态处理系统调用，处理视频显存，此时外部硬件中断开启
2. 8253可编程计时器产生一个时间中断
3. 在内核态处理系统调用的进程P1将现场信息压入P1的内核堆栈中，跳转执行时间中断处理程序
4. 进程P1的处理时间片耗尽，切换至就绪状态的进程P2，并从当前P1的内核堆栈切换至P2的内核堆栈
5. 从进程P2的内核堆栈中弹出P2的现场信息，从时间中断处理程序返回执行P2
6. 进程P2在内核态处理系统调用，处理视频显存，与进程P1形成竞争

在以下系统调用内核处理函数中利用`int $0x20`指令主动陷入时间中断来模拟以上场景

~~~~~~~~~~~~~~~~~~
void syscallPrint(struct StackFrame *sf) {
	...
	for (i = 0; i < size; i++) {
		asm volatile("movb %%es:(%1), %0":"=r"(character):"r"(str+i));
		if(character == '\n') {
			displayRow ++;
			displayCol = 0;
			if(displayRow == 25) {
				displayRow = 24;
				displayCol = 0;
				scrollScreen();
			}
		}
		else {
			data = character | (0x0c << 8);
			pos = (80*displayRow + displayCol) * 2;
			asm volatile("movw %0, (%1)"::"r"(data),"r"(pos+0xb8000));
			displayCol ++;
			if(displayCol == 80) {
				displayRow ++;
				displayCol = 0;
				if(displayRow == 25){
					displayRow = 24;
					displayCol = 0;
					scrollScreen();
				}
			}
		}
		asm volatile("int $0x20"); // 测试系统调用嵌套时间中断
	}
	...
}
~~~~~~~~~~~~~~~~~~

对编译生成的内核ELF文件进行反汇编，得到以下代码

~~~~~~~~~~~~~~~~~~
001005dc <syscallPrint>:
	...
  100606:	or  $0xc,%ah
  100609:	lea (%ecx,%ecx,4),%edx
  10060c:	shl $0x4,%edx
  10060f:	add 0x102404,%edx
  100615:	lea 0xb8000(%edx,%edx,1),%edx
  10061c:	mov %ax,(%edx)
  10061f:	mov 0x102404,%eax
  100624:	inc %eax
  100625:	mov %eax,0x102404
  10062a:	cmp $0x50,%eax
  10062d:	je  10063d
  10062f:	int $0x20
  100631:	inc %ebx
  100632:	cmp %esi,%ebx
  100634:	je  10066c
  100636:	mov %es:(%ebx),%al
  100639:	cmp $0xa,%al
  10063b:	jne 100606
  10063d:	inc %ecx
  10063e:	mov %ecx,0x102408
  100644:	mov $0x0,0x102404
  10064e:	cmp $0x19,%ecx
  100651:	jne 10062f
	...
00102404 <displayCol>:
  102404:	00 00
	...
00102408 <displayRow>:
  102408:	00 00
	...
~~~~~~~~~~~~~~~~~~

考虑以下场景

* P1从时钟中断返回，顺序执行
`0x100631`、`0x100632`、`0x100634`、`0x100636`、`0x100639`、`0x10063b`、
`0x10063d`、`0x10063e`、`0x100644`、`0x10064e`、`0x100651`、`0x10062f`，
再次陷入时间中断，切换至P2
* P2从时间中断返回，顺序执行
`0x100631`、`0x100632`、`0x100634`、`0x100636`、`0x100639`、`0x10063b`、
`0x100606`、`0x100609`、`0x10060c`、`0x10060f`、`0x100615`、`0x10061c`
* 全局变量`displayRow`的更新产生一致性问题

多个进程并发地进行系统调用，对共享资源进行竞争可能会产生一致性问题，带来未知的BUG；因此，在系统调用过程中，对于临界区的代码不宜开启外部硬件中断，而对于非临界区的代码，则可以开启外部硬件中断，允许中断嵌套

# 4. 相关资源
* [代码框架](lab03.zip)

# 5. 作业提交

截止时间：2017-5-5 00:00:00
