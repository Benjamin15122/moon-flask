---
layout: post
title: Lab 04
---

> 2017/05/25更新：删除资料中矛盾的地方，统一实验4的实现方式，另我会更新作业提交网站的ppt与课程资料同步

## 实验提交

截止时间: 2017/06/02 23:59:59 (如无特殊原因，截止时间后一周之内迟交的作业将损失50%的成绩(即使迟了 1 秒)，一周之后将不再接受任何形式的作业提交，请大家合理分配时间)

请大家在提交的实验报告中注明你的邮箱，方便我们及时给你一些反馈信息。

学术诚信: 如果你确实无法完成实验，你可以选择不提交，作为学术诚信的奖励，你将会获得10%的分数；但若发现抄袭现象，抄袭双方(或团体)在本次实验中得 0 分。

提交地址：http://cslabcms.nju.edu.cn/

提交格式: 你需要将整个工程打包上传，特别地，我们会清除中间结果重新编译，若编译不通过，你将损失相应的分数（请在报告中注明你实验所使用的 gcc 的版本，以便助教处理一些 gcc 版本带来的问题）. 我们会使用脚本进行批量解压缩. 压缩包的命名只能包含你的学号。另外为了防止编码问题，压缩包中的所有文件都不要包含中文.如果你需要多次提交，请先手动删除旧的提交记录(提交网站允许下载，删除自己的提交记录)，否则若脚本解压时出现多次提交相互覆盖的现象，后果自负.我们只接受以下格式的压缩包：

- tar.gz
- tar.bz2
- zip

若提交的压缩包因格式原因无法被脚本识别，后果自负。

请你在实验截止前务必确认你提交的内容符合要求(格式、相关内容等)，你可以下载你提交的内容进行确认。如果由于你的原因给我们造成了不必要的麻烦，视情况而定，在本次实验中你将会被扣除一定的分数，最高可达 50% 。

git 版本控制：我们建议你使用 git 管理你的项目，如果你提交的实验中包含均匀合理的 git 记录，你将会获得 20% 的分数奖励（请注意，本实验的 Makefile 是由你自己准备的，你可以选择像 PA 中一样在每一次 make 后增加新的 git 记录作为备份，但是请注意，这样生成的 git log 一般是无意义的，所以不能作为加分项）。为此，请你确认提交的压缩包中包含一个名为 .git 的文件夹。

实验报告要求：仅接受 pdf 格式的实验报告，不超过 3 页 A4 纸，字号不
能小于五号，请首先回答所有带问号的问题，然后尽可能表现出你实验过程的心得，你攻克的难题，你踩的不同寻常的坑。



分数分布：
- 实验主体：80%
- 实验报告：20%

解释：

1. 每次实验最多获得满分；
2. git 的分数奖励是在实验主体基础上计算的
3. git 记录是否“均匀合理”由助教判定；
4. 迟交扣除整个实验分数的 50% ；
5. 作弊扣除整个实验分数的 100% ；
6. 提交格式不合理扣除整个实验分数的一定比例；
7. 保留未解释细节的最终解释权。



## 信号量

### 背景知识

信号量的定义是理论课的内容，这里不展开讨论，下面是摘自中文维基百科的信号量的相关介绍：

信号量（英语：Semaphore），它以一个整数变量，提供信号，以确保在并行计算环境中，不同进程在访问共享资源时，不会发生冲突。是一种不需要使用忙碌等待的方法。

信号量的概念是由荷兰计算机科学家艾Dijkstra发明的，广泛的应用于不同的操作系统中。在系统中，给予每一个进程一个信号量，代表每个进程目前的状态，未得到控制权的进程会在特定地方被强迫停下来，等待可以继续进行的信号到来。如果信号量是一个任意的整数，通常被称为计数信号量，或一般信号量（general semaphore）；如果信号量只有二进制的0或1，称为二进制信号量（binary semaphore）。在linux系中，二进制信号量（binary semaphore）又称Mutex。

### POSIX对信号量的解释

这是对信号量的一些说明，请务必仔细阅读[相关原语](http://linux.die.net/man/7/sem_overview)

####具名信号量

具名信号量是通过唯一标识符区分的，最基本的具名信号量有四个原语：

- sem\_open：创建一个新的信号量或者打开一个已有的信号量
- sem\_close：某一个进程结束对一个信号量的使用之后，便可以用sem\_close来关闭该信号量
- sem\_wait：相当于P操作，将信号量减1，如果该信号量本来为0，则挂起当前进程
- sem\_post：相当于V操作，将信号量加1，如果该信号量本来为0，则唤醒因该信号量而挂起的进程

####匿名信号量

POSIX中对匿名信号量的要求是这样的：
线程共享的匿名信号量是存放在线程共享的空间中的，比如全局变量；
进程共享的匿名信号量必须存放在进程的**共享内存区**中。

回忆一下整个os实验，什么地方是**所有进程共享**的呢？你可以据此实现你的**进程**匿名信号量么？

不考虑进程间创建共享区的原语，匿名信号量也是四个基本原语：

- sem\_init: 初始化一个信号量
- sem\_wait：相当于P操作，将信号量减1，如果该信号量本来为0，则挂起当前进程/线程
- sem\_post：相当于V操作，将信号量加1，如果该信号量本来为0，则唤醒因该信号量而挂起的进程/线程
- sem\_destroy: 当不需要使用某个信号量后，就可以销毁该信号量

对此感兴趣的同学可以看看这个[问题](http://stackoverflow.com/questions/16400820/c-how-to-use-posix-semaphores-on-forked-processes)
这个题主没有好好RTFM，遇到了问题。然后得票最高的答主给题主介绍了通过共享内存方式使用匿名信号量的方法。

### 实现信号量相关的参考资料

- Linux的PV操作的实现可以作为一个参考[感人的中文资料](http://www.cnblogs.com/biyeymyhjob/archive/2012/07/21/2602015.html)


### 实现多线程

在lab2中，你实现了fork，用于创建一个与调用者几乎完全相同的进程。
但是进程模式让我们无法通过全局变量的方式来使用信号量。
因此为了方便的使用PV操作，我们可以实现一个支持多线程的OS
为此你需要增加一个系统调用用于创建一个新的线程，该系统调用的参数是一个函数的地址，和传入该函数的参数。

kernel需要做的工作是：

- 为新线程分配一个新的PCB
- 将原有的PCB中的映射拷贝一份（注意这里是浅拷贝）
- 为新的线程分配新的用户栈和内核栈
- 将传入的参数填写到新线程的Trapframe
- 将新线程的Trapframe中的esp置为新的用户栈顶，eip置为函数地址

从工作量来看，线程的创建比进程的创建更加简单。

### 多线程下的信号量

这里有一些值得思考的问题，比如：

- 普通的全局变量是不是可以被用户修改？
- linux进程和线程下匿名信号量的实现有什么本质区别？
- 结合你的os，你该怎样实现进程/线程的具名信号量？（可以纸上谈兵）

## 杂项

### 不同的框架

由于各位同学使用的代码的框架各不相同，而不同的框架中实现原子操作的方式也各不相同。
我们的讲义假设同学是通过关中断的方法实现的，如果有使用自旋锁的同学需要自行注意
自旋锁的占用和释放的时机。

在jos的代码中是有自旋锁的，但是jos的做法得到的效果事实上和我们的在内核态关中断的做法区别不大，
因为jos的基础实现保证了只有一个进程在内核态运行。

我们鼓励大家将jos的自旋锁移植到自己的OS中，
或者自己实现一个自旋锁，用于进行本实验。不过如果你认为自旋锁的使用较为麻烦，那么你可以
通过关中断的方式实现。

另外，有不少同学的实验依赖于时间和键盘中断，在lab4中，你需要在特定的部分关中断，
请务必注意。

### 结果展示方式

由于最初大家完成的用户进程都是游戏，而通过游戏展示进程/线程间通信的方式是比较困难的，
因此在本实验的基本要求中，没有游戏相关的部分。
为了展示你实现的进程/线程间通信，你需要通过你的进程/线程间通信方式解决**生产者和消费者问题**。

### tips

由某位同学提醒，我发现这个讲义实在是糟透了，所以为了同学们更好的理解，我已经删除了讲义部分内容。
在这里说明一下本次实验的推荐实现方式或者说是统一要求：

- 实现多线程（内核级的多线程）方便共享内存
- 实现匿名信号量的相关系统调用（从名称上兼容POSIX，但是具体参数可以自定）
- 使用线程间通信（信号量）解决生产者消费者问题

如果你已经实现了其他方式的信号量，请在实验报告中较详细的介绍你的实现（标明接口，让我可以轻松定位到代码）。