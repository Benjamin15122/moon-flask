---
layout: post
title: Lab 06
---

本实验是最后一个操作系统实验，并且是选做，即不做不扣分，做了可以加分。

## 实验提交

截止时间: 2017/06/30 23:59:59 (**注意：因为课程成绩提交的时间限制，本次实验迟交没有成绩！**)

请大家在提交的实验报告中注明你的邮箱，方便我们及时给你一些反馈信息。

学术诚信: 如果你确实无法完成实验，你可以选择不提交；若发现抄袭现象，抄袭双方(或团体)在本次实验中得 0 分。

提交地址：http://cslabcms.nju.edu.cn/

提交格式: 你需要将整个工程打包上传，特别地，我们会清除中间结果重新编译，若编译不通过，你将损失相应的分数（请在报告中注明你实验所使用的 gcc 的版本，以便助教处理一些 gcc 版本带来的问题）. 我们会使用脚本进行批量解压缩. 压缩包的命名只能包含你的学号。另外为了防止编码问题，压缩包中的所有文件都不要包含中文.如果你需要多次提交，请先手动删除旧的提交记录(提交网站允许下载，删除自己的提交记录)，否则若脚本解压时出现多次提交相互覆盖的现象，后果自负.我们只接受以下格式的压缩包：

- tar.gz
- tar.bz2
- zip

若提交的压缩包因格式原因无法被脚本识别，后果自负。

请你在实验截止前务必确认你提交的内容符合要求(格式、相关内容等)，你可以下载你提交的内容进行确认。如果由于你的原因给我们造成了不必要的麻烦，视情况而定，在本次实验中你将会被扣除一定的分数，最高可达 50% 。

git 版本控制：我们建议你使用 git 管理你的项目，如果你提交的实验中包含均匀合理的 git 记录，你将会获得 10% 的分数奖励（请注意，本实验的 Makefile 是由你自己准备的，你可以选择像 PA 中一样在每一次 make 后增加新的 git 记录作为备份，但是请注意，这样生成的 git log 一般是无意义的，所以不能作为加分项）。为此，请你确认提交的压缩包中包含一个名为 .git 的文件夹。

实验报告要求：本次实验你必须在实验报告中写明自己为shell实现了哪些功能，以方便助教测试。**如果你实现了某个功能但是没有在报告中注明，将不被记分。**然后你还应该在实验报告中写明实现过程。

分数分布：
助教根据实现情况给分


解释：
- 本次实验的加分加到整个实验上

## 实验要求

本次实验的目标是在文件系统的基础上实现一个简单的shell，在shell中你可以选择完成这些功能：

- ls
- cat
- grep
- touch
- echo
- 重定向
- cd：
- 执行程序
- readline
- [Ctrl-C]

以下是对上述指令的解释。

### ls		[注意！后面所有的命令全部依赖于ls，即必须在实现了ls之后才能获得加分]
ls是Linux中的一个常用指令，其基本功能就不必赘述了。ls有很多选项，最常用的是-a, -t和-h。

- 必须实现：	[20分]
	- ls -a：显示目录下所有文件；ls显示目录下除了以"."开头的文件外的其它文件；
	- ls -l：输出文件的详细信息；
	- 选项的正交性：比如，ls -a -l输出所有文件的详细信息；
- 可选实现：	[10分]
	- ls -t：按最后修改时间顺序输出（依赖于文件的时间戳）；
	- ls -h：输出的文件大小用B, KB, MB等单位表示。

### cat		[5分]	
实现基本功能即可

### grep      [5分]
实现最简单的在本目录下查找包含特定内容的文件，输出文件名。

### touch	[10分，依赖于文件的时间戳]
Linux的[touch](http://linux.die.net/man/1/touch)的功能详见链接，必须实现-c选项，其它选项可选。

### echo	[5分]
实现基本功能即可

### >, >>	[20分,依赖于cat和echo]
实现重定向功能。考虑到如果程序结构设计不合理，实现重定向功能十分困难，因此我们只要求对echo和cat指令做重定向。
在这种放宽的条件下，你可以将重定向的符号看作是cat或者echo的一个选项。

### cd		[15分，依赖于lab4的选做]
如果你在lab5中完成了多级目录，那么你可以在ls的基础上可以选择完成cd命令。
需要注意的是，如果要完成cd，那么必须支持文件的“相对路径”访问，这是一个挑战。

### 执行程序	[10分]
执行用户给定的可执行文件，若给定的字符串不是可执行文件，那么进行错误提示

### readline	[20分，依赖于上面所有的命令，因为指令太少的话readline没有意义]
即在NEMU中使用到的libreadline的部分功能。

- 必须完成：通过“↑”键得到历史输入的命令
- 其它自选

### [Ctrl-C]		[30分，依赖于“执行程序”]
终止正在执行的程序，或清除正在输入的命令，有相当大的挑战性。

## 实验参考资料

1. [JOS](https://pdos.csail.mit.edu/6.828/2014/tools.html)中从lab1开始便有一个基本的shell，有基本的执行逻辑，可以选择直接继承JOS的响应代码，也可以借鉴其中的一些设计。
2. NEMU中的UI设计也是一个不错的参考，包括用户命令的解析。注意，我们没有正则表达式库可以使用，因此可以对文件名做出限制以简化实现。
3. 关于Linux命令的功能，请RTFM

## 实验内容

在类Unix操作系统中, fork是创建新进程的唯一途径， exec是执行新程序的唯一途径。fork我们已经讲过了！

### exec系统调用

调用exec的用户进程将会被一个全新的进程所取代. 执行的程序位于文件系统中, 你之前已经实现了一个简易文件系统了, 因此exec的函数原型如下:

```c
int exec(char* filename, char *args);
```

其中filename是一个整数, args是一个字符串. 通常一个程序可以接受多个参数, 在我们实现时可以做简化, 将这些参数编码成一个字符串, 其中用空格将它们分隔开, 例如:

```c
exec("game", "gcc -O2 -o hello hello.c");
```

至于如何从args中解析出每个参数, 就是用户进程的工作了. 为了配合实验的这一简化, 用户进程的main函数需要定义成如下形式:

```c
int main(char *args);
```

此外, 编译用户进程的时候, 还需要加上-Wno-main的编译选项, 否则gcc会因为main函数的参数不符合标准而报错.

exec需要做的事情十分直观:

- 回收当前进程的"所有"资源(有少量资源需要继承, 例如PID, 文件描述符表)
- 重新创建地址空间
- 载入目标程序
- 初始化PCB和堆栈
- 将新进程放到就绪队列中

可以看到, 除了回收资源之外, exec需要做的事情跟载入第一个用户进程十分相似, 甚至相似到可以使用同一个函数来实现. 唯一不同的是初始化堆栈的时候, 需要将参数放到堆栈上, 用户进程运行的时候, 可以在main函数中访问它: args可以获得执行exec时传入的args参数, 例如用户进程可以通过

```c
printf("args = %s\n", args);
```

来输出参数. 在实现的过程中, 你会面临两个问题:

- exec中的参数如何传入内核？也许你会想执行exec的用户进程通过int $0x80陷入内核的时候, 字符串首地址已经存放到tf->ecx里面了, 内核读取这个值就可以了。事实上并非如此, 别忘了从用户进程到内核需要经过上下文切换, 地址空间也跟着切换了，这意味着在分页机制的作用下, 内核得到的字符串首地址被映射到其它物理地址。这里提供一个思路：将用户的
页目录和页表拷贝到内核。
- 如何正确地放置参数？参数要放在用户栈中，程序执行时才能访问。这个
需要你了解函数体如何访问它栈中的参数，然后仿照一个栈就行。

**进阶**（非必须，供学有余力的同学提升自己）

尝试实现与

```c
int main(int argc, char* argv[]);
```

相对应的exec版本.

你需要注意如何处理argv这个指针数组的实体: 在argv这个指针数组的实体中, 数组的第一个元素指向第一个参数字符串, 第二个元素指向第二个参数字符串, 如此类推. 数组元素的个数需要与argc的值相符, 换句话说, 如果有n个参数, argc的值为n, argv的实体就应该占4n个字节. 你不但需要将参数的实体(字符串)放入堆栈, 还需要将argv的实体放入堆栈, 否则你将无法通过argv访问相应的参数字符串.

你遇到的挑战是如何正确设置这些指针的值. 你可以从man exec中查阅关于exec家族的信息。

### 简易shell

你需要实现fork, exec, exit, getpid, waitpid这5个
系统调用，waitpid我们至今还没有讲过，它的作用就是检查某个进程有没有结束，
如果没有就阻塞自己，等待进程执行完。

有了这些系统调用，你已经可以实现一个简易shell了。shell的执行框架十分简单:

```c
while(1) {
	read_line(cmd);
	filename = parse(cmd);
	if( (pid = fork()) == 0) {
		exec(filename, cmd);
	}
	else {
		waitpid(pid);
	}
}
```

可以看到，shell的框架就是一个循环， 每次从键盘读入命令(这部分游戏中应该已经有了，直接调用)。 命令的第一个参数是可执行文件的文件名; 此外命令还可以带多个参数。 读入命令后，shell通过fork系统调用创建一个子进程， 并让子进程通过exec系统调用执行输出的命令； 父进程则通过waitpid系统调用等待子进程结束，并进入新一轮循环。 这一切都和我们经常使用的终端十分相似。

你可以把简易shell作为第一个**用户**进程，让内核将它载入，这样就可以运行简易shell了。

### shell命令

前面提到的cd, ls, grep, cat, echo等，它们都依赖于你之前实现的系统调用。 你可以将它们的二进制文件放在根目录下，使用copy2myfs将文件拷贝到img镜像的
文件系统中，然后你就可以在shell中直接使用这些小工具了。到这里，你也终于可以做到在shell中输入你的游戏名就执行游戏了，有没有一点小激动呢。

一个例外是cd命令。若将cd实现成外部命令，通过fork-exec来执行它，它改变的是子进程的当前目录，并不能改变shell的当前目录，因此它必须实现成shell的内部命令（有兴趣的同学看[这里](https://linux.die.net/man/1/bash)，很长，找到cd的部分看一看）。

编写完shell后, 将shell的二进制文件写入镜像文件(使用copy2myfs), 并让内核将shell作为第一个用户进程载入。

本讲义主要参考jyy的nanos讲义，如果你对实现真正的重定向有较大兴趣，建议参考jyy讲义的相关部分（这部分对文件系统要求较高，需要封装设备文件）。


##结束语

到这里本期的oslab课就到此为止，我也是第一次做助教，对实验还不是特别了解，如果有什么不好的地方，请大家多多包涵！鞠躬！！！